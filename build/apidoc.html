<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://github.com/jrburke/r.js"

    >requirejs (v2.3.3)</a>
</h1>
<h4>Node adapter for RequireJS, for loading AMD modules. Includes RequireJS optimizer</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.requirejs">module requirejs</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">requirejs.</span>isBrowser</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.config">
            function <span class="apidocSignatureSpan">requirejs.</span>config
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.createNode">
            function <span class="apidocSignatureSpan">requirejs.</span>createNode
            <span class="apidocSignatureSpan">(config, moduleName, url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.define">
            function <span class="apidocSignatureSpan">requirejs.</span>define
            <span class="apidocSignatureSpan">(name, deps, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.defined">
            function <span class="apidocSignatureSpan">requirejs.</span>defined
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.exec">
            function <span class="apidocSignatureSpan">requirejs.</span>exec
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.get">
            function <span class="apidocSignatureSpan">requirejs.</span>get
            <span class="apidocSignatureSpan">(context, moduleName, relModuleMap, localRequire)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.load">
            function <span class="apidocSignatureSpan">requirejs.</span>load
            <span class="apidocSignatureSpan">(context, moduleName, url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.makeNodeWrapper">
            function <span class="apidocSignatureSpan">requirejs.</span>makeNodeWrapper
            <span class="apidocSignatureSpan">(contents)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.nextTick">
            function <span class="apidocSignatureSpan">requirejs.</span>nextTick
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.nodeRequire">
            function <span class="apidocSignatureSpan">requirejs.</span>nodeRequire
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.onError">
            function <span class="apidocSignatureSpan">requirejs.</span>onError
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.optimize">
            function <span class="apidocSignatureSpan">requirejs.</span>optimize
            <span class="apidocSignatureSpan">(config, callback, errback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.specified">
            function <span class="apidocSignatureSpan">requirejs.</span>specified
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.toUrl">
            function <span class="apidocSignatureSpan">requirejs.</span>toUrl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.undef">
            function <span class="apidocSignatureSpan">requirejs.</span>undef
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">requirejs.</span>jsExtRegExp</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">requirejs.</span>nodeRequire.extensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">requirejs.</span>s</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">requirejs.</span>tools</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">requirejs.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.requirejs.nodeRequire">module requirejs.nodeRequire</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.nodeRequire.nodeRequire">
            function <span class="apidocSignatureSpan">requirejs.</span>nodeRequire
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.nodeRequire.resolve">
            function <span class="apidocSignatureSpan">requirejs.nodeRequire.</span>resolve
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">requirejs.nodeRequire.</span>cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">requirejs.nodeRequire.</span>extensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">requirejs.nodeRequire.</span>main</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.requirejs.nodeRequire.extensions">module requirejs.nodeRequire.extensions</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.requirejs.s">module requirejs.s</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.s.newContext">
            function <span class="apidocSignatureSpan">requirejs.s.</span>newContext
            <span class="apidocSignatureSpan">(contextName)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">requirejs.s.</span>contexts</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.requirejs.tools">module requirejs.tools</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.requirejs.tools.useLib">
            function <span class="apidocSignatureSpan">requirejs.tools.</span>useLib
            <span class="apidocSignatureSpan">(contextName, callback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.requirejs" id="apidoc.module.requirejs">module requirejs</a></h1>




    <h2>
        <a href="#apidoc.element.requirejs.config" id="apidoc.element.requirejs.config">
        function <span class="apidocSignatureSpan">requirejs.</span>config
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function (config) {
    return req(config);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        context.configure(config);
    }

    return context.require(deps, callback, errback);
};

/**
 * Support require.<span class="apidocCodeKeywordSpan">config</span>() to make it easier to cooperate with other
 * AMD loaders on globally agreed names.
 */
req.config = function (config) {
    return req(config);
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.createNode" id="apidoc.element.requirejs.createNode">
        function <span class="apidocSignatureSpan">requirejs.</span>createNode
        <span class="apidocSignatureSpan">(config, moduleName, url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createNode = function (config, moduleName, url) {
    var node = config.xhtml ?
            document.createElementNS(&#x27;http://www.w3.org/1999/xhtml&#x27;, &#x27;html:script&#x27;) :
            document.createElement(&#x27;script&#x27;);
    node.type = config.scriptType || &#x27;text/javascript&#x27;;
    node.charset = &#x27;utf-8&#x27;;
    node.async = true;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context &#x26;&#x26; context.config) || {},
node;
        if (isBrowser) {
//In the browser so use a script tag
node = req.<span class="apidocCodeKeywordSpan">createNode</span>(config, moduleName, url);

node.setAttribute(&#x27;data-requirecontext&#x27;, context.contextName);
node.setAttribute(&#x27;data-requiremodule&#x27;, moduleName);

//Set up load listener. Test attachEvent first because IE9 has
//a subtle issue in its addEventListener and script onload firings
//that do not match the behavior of all other browsers with
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.define" id="apidoc.element.requirejs.define">
        function <span class="apidocSignatureSpan">requirejs.</span>define
        <span class="apidocSignatureSpan">(name, deps, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">define = function (name, deps, callback) {
    var node, context;

    //Allow for anonymous modules
    if (typeof name !== &#x27;string&#x27;) {
        //Adjust args appropriately
        callback = deps;
        deps = name;
        name = null;
    }

    //This module may not have dependencies
    if (!isArray(deps)) {
        callback = deps;
        deps = null;
    }

    //If no name, and callback is a function, then figure out if it a
    //CommonJS thing with dependencies.
    if (!deps &#x26;&#x26; isFunction(callback)) {
        deps = [];
        //Remove comments from the callback string,
        //look for require calls, and pull them into the dependencies,
        //but only if there are function args.
        if (callback.length) {
            callback
                .toString()
                .replace(commentRegExp, commentReplace)
                .replace(cjsRequireRegExp, function (match, dep) {
                    deps.push(dep);
                });

            //May be a CommonJS thing even without require calls, but still
            //could use exports, and module. Avoid doing exports and module
            //work though if it just needs require.
            //REQUIRES the function to expect the CommonJS variables in the
            //order listed below.
            deps = (callback.length === 1 ? [&#x27;require&#x27;] : [&#x27;require&#x27;, &#x27;exports&#x27;, &#x27;module&#x27;]).concat(deps);
        }
    }

    //If in IE 6-8 and hit an anonymous define() call, do the interactive
    //work.
    if (useInteractive) {
        node = currentlyAddingScript || getInteractiveScript();
        if (node) {
            if (!name) {
                name = node.getAttribute(&#x27;data-requiremodule&#x27;);
            }
            context = contexts[node.getAttribute(&#x27;data-requirecontext&#x27;)];
        }
    }

    //Always save off evaluating the def call until the script onload handler.
    //This allows multiple modules to be in a file without prematurely
    //tracing dependencies, and allows for anonymous module support,
    //where the module name is not known until the script onload event
    //occurs. If no context, use the global queue, and get it processed
    //in the onscript load callback.
    if (context) {
        context.defQueue.push([name, deps, callback]);
        context.defQueueMap[name] = true;
    } else {
        globalDefQueue.push([name, deps, callback]);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.defined" id="apidoc.element.requirejs.defined">
        function <span class="apidocSignatureSpan">requirejs.</span>defined
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defined = function () {
    var ctx = contexts[defContextName];
    return ctx.require[prop].apply(ctx, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.exec" id="apidoc.element.requirejs.exec">
        function <span class="apidocSignatureSpan">requirejs.</span>exec
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (text) {
<span class="apidocCodeCommentSpan">    /*jslint evil: true */
</span>    text = req.makeNodeWrapper(text);
    return eval(text);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.3 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.<span class="apidocCodeKeywordSpan">exec</span>()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
var req, s, head, baseElement, dataMain, src,
    interactiveScript, currentlyAddingScript, mainScript, subPath,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.get" id="apidoc.element.requirejs.get">
        function <span class="apidocSignatureSpan">requirejs.</span>get
        <span class="apidocSignatureSpan">(context, moduleName, relModuleMap, localRequire)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (context, moduleName, relModuleMap, localRequire) {
    if (moduleName === &#x22;require&#x22; || moduleName === &#x22;exports&#x22; || moduleName === &#x22;module&#x22;) {
        context.onError(makeError(&#x22;Explicit require of &#x22; + moduleName + &#x22; is not allowed.&#x22;, moduleName));
    }

    var ret, oldTick,
        moduleMap = context.makeModuleMap(moduleName, relModuleMap, false, true);

    //Normalize module name, if it contains . or ..
    moduleName = moduleMap.id;

    if (hasProp(context.defined, moduleName)) {
        ret = context.defined[moduleName];
    } else {
        if (ret === undefined) {
            //Make sure nextTick for this type of call is sync-based.
            oldTick = context.nextTick;
            context.nextTick = syncTick;
            try {
                if (moduleMap.prefix) {
                    //A plugin, call requirejs to handle it. Now that
                    //nextTick is syncTick, the require will complete
                    //synchronously.
                    localRequire([moduleMap.originalName]);

                    //Now that plugin is loaded, can regenerate the moduleMap
                    //to get the final, normalized ID.
                    moduleMap = context.makeModuleMap(moduleMap.originalName, relModuleMap, false, true);
                    moduleName = moduleMap.id;
                } else {
                    //Try to dynamically fetch it.
                    req.load(context, moduleName, moduleMap.url);

                    //Enable the module
                    context.enable(moduleMap, relModuleMap);
                }

                //Break any cycles by requiring it normally, but this will
                //finish synchronously
                context.require([moduleName]);

                //The above calls are sync, so can do the next thing safely.
                ret = context.defined[moduleName];
            } finally {
                context.nextTick = oldTick;
            }
        }
    }

    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (relMap &#x26;&#x26; hasProp(handlers, deps)) {
    return handlers[deps](registry[relMap.id]);
}

//Synchronous access to one module. If require.get is
//available (as in the Node adapter), prefer that.
if (req.get) {
    return req.<span class="apidocCodeKeywordSpan">get</span>(context, deps, relMap, localRequire);
}

//Normalize module name, if it contains . or ..
map = makeModuleMap(deps, relMap, false, true);
id = map.id;

if (!hasProp(defined, id)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.load" id="apidoc.element.requirejs.load">
        function <span class="apidocSignatureSpan">requirejs.</span>load
        <span class="apidocSignatureSpan">(context, moduleName, url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (context, moduleName, url) {
    var contents, err,
        config = context.config;

    if (config.shim[moduleName] &#x26;&#x26; (!config.suppress || !config.suppress.nodeShim)) {
        console.warn(&#x27;Shim config not supported in Node, may or may not work. Detected &#x27; +
                        &#x27;for module: &#x27; + moduleName);
    }

    if (exists(url)) {
        contents = fs.readFileSync(url, &#x27;utf8&#x27;);

        contents = req.makeNodeWrapper(contents);
        try {
            vm.runInThisContext(contents, fs.realpathSync(url));
        } catch (e) {
            err = new Error(&#x27;Evaluating &#x27; + url + &#x27; as module &#x22;&#x27; +
                            moduleName + &#x27;&#x22; failed with error: &#x27; + e);
            err.originalError = e;
            err.moduleName = moduleName;
            err.requireModules = [moduleName];
            err.fileName = url;
            return context.onError(err);
        }
    } else {
        def(moduleName, function () {
            //Get the original name, since relative requires may be
            //resolved differently in node (issue #202). Also, if relative,
            //make it relative to the URL of the item requesting it
            //(issue #393)
            var dirName,
                map = hasProp(context.registry, moduleName) &#x26;&#x26;
                        context.registry[moduleName].map,
                parentMap = map &#x26;&#x26; map.parentMap,
                originalName = map &#x26;&#x26; map.originalName;

            if (originalName.charAt(0) === &#x27;.&#x27; &#x26;&#x26; parentMap) {
                dirName = parentMap.url.split(&#x27;/&#x27;);
                dirName.pop();
                originalName = dirName.join(&#x27;/&#x27;) + &#x27;/&#x27; + originalName;
            }

            try {
                return (context.config.nodeRequire || req.nodeRequire)(originalName);
            } catch (e) {
                err = new Error(&#x27;Tried loading &#x22;&#x27; + moduleName + &#x27;&#x22; at &#x27; +
                                 url + &#x27; then tried node\&#x27;s require(&#x22;&#x27; +
                                    originalName + &#x27;&#x22;) and it failed &#x27; +
                                 &#x27;with error: &#x27; + e);
                err.originalError = e;
                err.moduleName = originalName;
                err.requireModules = [moduleName];
                throw err;
            }
        });
    }

    //Support anonymous modules.
    context.completeLoad(moduleName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    //If the manager is for a plugin managed resource,
    //ask the plugin to load it now.
    if (this.shim) {
        context.makeRequire(this.map, {
            enableBuildCallback: true
        })(this.shim.deps || [], bind(this, function () {
            return map.prefix ? this.callPlugin() : this.<span class="apidocCodeKeywordSpan">load</span>();
        }));
    } else {
        //Regular dependency.
        return map.prefix ? this.callPlugin() : this.load();
    }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.makeNodeWrapper" id="apidoc.element.requirejs.makeNodeWrapper">
        function <span class="apidocSignatureSpan">requirejs.</span>makeNodeWrapper
        <span class="apidocSignatureSpan">(contents)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeNodeWrapper = function (contents) {
    return &#x27;(function (require, requirejs, define) { &#x27; +
            contents +
            &#x27;\n}(requirejsVars.require, requirejsVars.requirejs, requirejsVars.define));&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.nextTick" id="apidoc.element.requirejs.nextTick">
        function <span class="apidocSignatureSpan">requirejs.</span>nextTick
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextTick = function (fn) {
    process.nextTick(fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.<span class="apidocCodeKeywordSpan">nextTick</span>(function () {
//Some defines could have been added since the
//require call, collect them.
intakeDefines();

requireMod = getModule(makeModuleMap(null, relMap));

//Store if map config should be applied to this require
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.nodeRequire" id="apidoc.element.requirejs.nodeRequire">
        function <span class="apidocSignatureSpan">requirejs.</span>nodeRequire
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function require(path) {
  try {
    exports.requireDepth += 1;
    return self.require(path);
  } finally {
    exports.requireDepth -= 1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.onError" id="apidoc.element.requirejs.onError">
        function <span class="apidocSignatureSpan">requirejs.</span>onError
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultOnError(err) {
    throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                    notified = true;
                    mod.emit(&#x27;error&#x27;, err);
                }
            }
        });

        if (!notified) {
            req.<span class="apidocCodeKeywordSpan">onError</span>(err);
        }
    }
}

/**
 * Internal method to transfer globalQueue items to this context&#x27;s
 * defQueue.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.optimize" id="apidoc.element.requirejs.optimize">
        function <span class="apidocSignatureSpan">requirejs.</span>optimize
        <span class="apidocSignatureSpan">(config, callback, errback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">optimize = function (config, callback, errback) {
    if (!loadedOptimizedLib) {
        loadLib();
        loadedOptimizedLib = true;
    }

    //Create the function that will be called once build modules
    //have been loaded.
    var runBuild = function (build, logger, quit) {
        //Make sure config has a log level, and if not,
        //make it &#x22;silent&#x22; by default.
        config.logLevel = config.hasOwnProperty(&#x27;logLevel&#x27;) ?
                          config.logLevel : logger.SILENT;

        //Reset build internals first in case this is part
        //of a long-running server process that could have
        //exceptioned out in a bad state. It is only defined
        //after the first call though.
        if (requirejs._buildReset) {
            requirejs._buildReset();
            requirejs._cacheReset();
        }

        function done(result) {
            //And clean up, in case something else triggers
            //a build in another pathway.
            if (requirejs._buildReset) {
                requirejs._buildReset();
                requirejs._cacheReset();
            }

            // Ensure errors get propagated to the errback
            if (result instanceof Error) {
              throw result;
            }

            return result;
        }

        errback = errback || function (err) {
            // Using console here since logger may have
            // turned off error logging. Since quit is
            // called want to be sure a message is printed.
            console.log(err);
            quit(1);
        };

        build(config).then(done, done).then(callback, errback);
    };

    requirejs({
        context: &#x27;build&#x27;
    }, [&#x27;build&#x27;, &#x27;logger&#x27;, &#x27;env!env/quit&#x27;], runBuild);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.specified" id="apidoc.element.requirejs.specified">
        function <span class="apidocSignatureSpan">requirejs.</span>specified
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">specified = function () {
    var ctx = contexts[defContextName];
    return ctx.require[prop].apply(ctx, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.toUrl" id="apidoc.element.requirejs.toUrl">
        function <span class="apidocSignatureSpan">requirejs.</span>toUrl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toUrl = function () {
    var ctx = contexts[defContextName];
    return ctx.require[prop].apply(ctx, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.undef" id="apidoc.element.requirejs.undef">
        function <span class="apidocSignatureSpan">requirejs.</span>undef
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">undef = function () {
    var ctx = contexts[defContextName];
    return ctx.require[prop].apply(ctx, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig &#x26;&#x26; isArray(pathConfig) &#x26;&#x26; pathConfig.length &#x3e; 1) {
//Pop off the first array value, since it failed, and
//retry
pathConfig.shift();
context.require.<span class="apidocCodeKeywordSpan">undef</span>(id);

//Custom require that does not do map translation, since
//ID is &#x22;absolute&#x22;, already mapped/resolved.
context.makeRequire(null, {
    skipMap: true
})([id]);
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.requirejs.nodeRequire" id="apidoc.module.requirejs.nodeRequire">module requirejs.nodeRequire</a></h1>


    <h2>
        <a href="#apidoc.element.requirejs.nodeRequire.nodeRequire" id="apidoc.element.requirejs.nodeRequire.nodeRequire">
        function <span class="apidocSignatureSpan">requirejs.</span>nodeRequire
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function require(path) {
  try {
    exports.requireDepth += 1;
    return self.require(path);
  } finally {
    exports.requireDepth -= 1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.requirejs.nodeRequire.resolve" id="apidoc.element.requirejs.nodeRequire.resolve">
        function <span class="apidocSignatureSpan">requirejs.nodeRequire.</span>resolve
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(request) {
  return Module._resolveFilename(request, self);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.requirejs.nodeRequire.extensions" id="apidoc.module.requirejs.nodeRequire.extensions">module requirejs.nodeRequire.extensions</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.requirejs.s" id="apidoc.module.requirejs.s">module requirejs.s</a></h1>


    <h2>
        <a href="#apidoc.element.requirejs.s.newContext" id="apidoc.element.requirejs.s.newContext">
        function <span class="apidocSignatureSpan">requirejs.s.</span>newContext
        <span class="apidocSignatureSpan">(contextName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function newContext(contextName) {
    var inCheckLoaded, Module, context, handlers,
        checkLoadedTimeoutId,
        config = {
            //Defaults. Do not set a default for map
            //config to speed up normalize(), which
            //will run faster if there is no default.
            waitSeconds: 7,
            baseUrl: &#x27;./&#x27;,
            paths: {},
            bundles: {},
            pkgs: {},
            shim: {},
            config: {}
        },
        registry = {},
        //registry of just enabled modules, to speed
        //cycle breaking code when lots of modules
        //are registered, but not activated.
        enabledRegistry = {},
        undefEvents = {},
        defQueue = [],
        defined = {},
        urlFetched = {},
        bundlesMap = {},
        requireCounter = 1,
        unnormalizedCounter = 1;

<span class="apidocCodeCommentSpan">    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
</span>    function trimDots(ary) {
        var i, part;
        for (i = 0; i &#x3c; ary.length; i++) {
            part = ary[i];
            if (part === &#x27;.&#x27;) {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === &#x27;..&#x27;) {
                // If at the start, or previous value is still ..,
                // keep them so that when converted to a path it may
                // still work when converted to a path, even though
                // as an ID it is less than ideal. In larger point
                // releases, may be better to just kick out an error.
                if (i === 0 || (i === 1 &#x26;&#x26; ary[2] === &#x27;..&#x27;) || ary[i - 1] === &#x27;..&#x27;) {
                    continue;
                } else if (i &#x3e; 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @param {Boolean} applyMap apply the map config to the value. Should
     * only be done if this normalization is for a dependency ID.
     * @returns {String} normalized name
     */
    function normalize(name, baseName, applyMap) {
        var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
            foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
            baseParts = (baseName &#x26;&#x26; baseName.split(&#x27;/&#x27;)),
            map = config.map,
            starMap = map &#x26;&#x26; map[&#x27;*&#x27;];

        //Adjust any relative paths.
        if (name) {
            name = name.split(&#x27;/&#x27;);
            lastIndex = name.length - 1;

            // If wanting node ID compatibility, strip .js from end
            // of IDs. Have to do this here, and not in nameToUrl
            // because node allows either .js or non .js to map
            // to same file.
            if (config.nodeIdCompat &#x26;&#x26; jsSuffixRegExp.test(name[lastIndex])) {
                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, &#x27;&#x27;);
            }

            // Starts with a &#x27;.&#x27; so need the baseName
            if (name[0].charAt(0) === &#x27;.&#x27; &#x26;&#x26; baseParts) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that &#x27;directory&#x27; and not name of the baseName&#x27;s
                //module. For instance, baseName of &#x27;one/two/three&#x27;, maps to
                //&#x27;one/two/three.js&#x27;, but we want the directory, &#x27;one/two&#x27; for
                //this normalization.
                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                name = normalizedBaseParts.concat(name);
            } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (config &#x26;&#x26; config.context) {
    contextName = config.context;
}

context = getOwn(contexts, contextName);
if (!context) {
    context = contexts[contextName] = req.s.<span class="apidocCodeKeywordSpan">newContext</span>(contextName);
}

if (config) {
    context.configure(config);
}

return context.require(deps, callback, errback);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.requirejs.tools" id="apidoc.module.requirejs.tools">module requirejs.tools</a></h1>


    <h2>
        <a href="#apidoc.element.requirejs.tools.useLib" id="apidoc.element.requirejs.tools.useLib">
        function <span class="apidocSignatureSpan">requirejs.tools.</span>useLib
        <span class="apidocSignatureSpan">(contextName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">useLib = function (contextName, callback) {
    if (!callback) {
        callback = contextName;
        contextName = &#x27;uselib&#x27;;
    }

    if (!useLibLoaded[contextName]) {
        loadLib();
        useLibLoaded[contextName] = true;
    }

    var req = requirejs({
        context: contextName
    });

    req([&#x27;build&#x27;], function () {
        callback(req);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
